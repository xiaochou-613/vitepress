# 递归排序

```c
#include <iostream>
using namespace std;

void sort(float *a ,int n)
{
  float t;
  if(n==1) return 1;
  	sort(a,n-1);
  if(a[n-1]<a[n-2])
    {       
		t=a[n-1],a[n-1]=a[n-2],a[n-2]=t;
      	sort(a,n-1);           
    }                
}


int main()
{
	float a[] = {11,2,8,9,7,4,5,3,6,1};
	if(sort(a,10))
		for(int i=0;i<10;i++)
			cout << a[i]<<endl;	
	return 0;
} 
```

# 递归创建单链表

```c
typedef struct chain{
    char  data;
    struct chain *next;
}jd;
```

```C
#include <iostream>
#include <stdlib.h>
#include <string.h>
using namespace std;

typedef struct chain
{
	char data;
	struct chain * next;
}jd;

jd *crechain(char *ch,int n) //返回一个没有头结点的链表 
{
    jd *p,*q=NULL;     
	for(int i=n-1;i>=0;i--)   
	{
		p= ( jd *)malloc(sizeof(jd));     
	    p->data=ch[i];     
	    p->next=q;       
	    q=p;    
	} 
    return p; 
}

void show(jd* head)
{
	jd * p = head;
	if(p == NULL) return;
	cout << p->data<<endl;
	show(p->next);
}

int main()
{
	char a[20];
	printf("请输入一个字符串：\n");
	cin >> a;
	jd* head = crechain(a,strlen(a)); 
	show(head);
	
	return 0;
}
```

# 栈的基础用法

```c
#define MAXSIZE 100
typedef char datatype;
typedef  struct  stack{
    datatype  data[MAXSIZE];
    int top;
}stk;
```

```c
#include <iostream>
#include <stdlib.h>
#include <string.h>
using namespace std;
#define MAXSIZE 100

typedef char datatype;
typedef  struct  stack{
    datatype  data[MAXSIZE];
    int top;
}stk;


void  push(stk *s , datatype  x)
{
   if(s->top == MAXSIZE-1)     
    {
     	printf("满栈还要塞？\n");
     	return;
    }
    else
    {
        s->top++;    
        s->data[s->top]=x;    
    }   
}  
	           
datatype  pop(stk *s)     
{                                               
	if(s->top == -1)    
	{
	    printf("空了还要榨？\n");
	    return 0;
	}
	else
		return s->data[s->top--];
}

int main()
{
	datatype a[100];
	cout << "请输入一个字符串: ";
	cin >> a;
	
	stk * s;
	s = (stk*)malloc(sizeof(stk));
	
	for(int i = 0;i<strlen(a);i++)
		push(s,a[i]); 
	
	for(int i = 0;i<strlen(a);i++)
		cout << pop(s) << endl;

	return 0;
} 
```

