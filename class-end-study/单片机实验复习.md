# 实验一

 

```c
#include <reg51.h>
#include<intrins.h>  
#define uint unsigned int // 写这样的写东西会加分
void delay(uint i)
{
    uint j;    // 最好改成int
    while(i--)
    {
        for(j=0;j<128;j++);
    }
}

void main()
{
	P1=0xfe;  //亮最后一个
	while(1)
	{
		delay(500);
		P1 = _crol_(P1,1); //应该是控制左移 control left
	}
}
```

# 实验二

 

```c
#include <reg51.h>
#define uchar unsigned char   //这个是仿真的程序，引脚不一样
void main()
{
	uchar state;    
	while(1)
	{
		P1=0xff;
		state = P1; 
		state = state&0x03;   //0000 0011 屏蔽其他位 
		switch(state)
		{
			case 0:P2=~0x01;break;
			case 1:P2=~0x02;break;
			case 2:P2=~0x04;break;
			case 3:P2=~0x08;break;
		}
	}
}
```



```c
#include <reg51.h>
#define uchar unsigned char   //这个实验板程序，引脚不一样  P1.4  P1.5
void main()
{
	uchar state;    //这样的话必须在外面定义，否则会报错
	while(1)
	{
		P1=0xff;
		state = P1; 
		state = (state&0x30)>>4;   //0000 0011
		switch(state)
		{
			case 0:P2=~0x01;break;
			case 1:P2=~0x02;break;
			case 2:P2=~0x04;break;
			case 3:P2=~0x08;break;
		}
	}
}
```

# 实验三

==定时/计数+中断综合控制实验==

 

 

```c
#include <reg51.h>
#define TIMER_COUNT 20
char i = 0;

void main()
{
    TMOD = 0x01;  // 设置定时器T0为模式1
    TH0 = (65536-50000)/256;  // 初始化定时器初值的高字节
    TL0 = (65536-50000)%256;  // 初始化定时器初值的低字节
    P1 = 0x00;  // 将P1口初始化为0
    EA = 1;  // 开启总中断允许位
    ET0 = 1;  // 开启定时器T0中断允许位
    TR0 = 1;  // 启动定时器T0
    while(1); 
}

void timer() interrupt 1
{
    i++;
    if(i == TIMER_COUNT)
    {
        P1 = ~P1;  // 反转P1口的状态
        i = 0;  // 重置计数器
    }
    TH0 = (65536-50000)/256;  // 重新加载定时器初值的高字节
    TL0 = (65536-50000)%256;  // 重新加载定时器初值的低字节
    //TF0 = 0;  // 不需要手动清除TF0，硬件会在中断发生时自动清除，查询则需要
}
```

## 初值的计算

| 定时时长 | 机器周期 |
| :------: | :------: |
| 65.536ms |  65536   |
| 50.000ms |  50000   |

当到65536的时候，就会溢出，假设设置50ms，则需要50000个机器周期，初值设为65536-50000=15536

TH0 = （65536-50000）/ 256;    --  高八位

TL0 = （65536-50000）%256;    --  低八位

## 溢出

如果溢出了，TF0会被自动置1，如果下次想要计时就不行。中断会自动清零，但是查询不会、所以需要手动置0；

## T1的计数器中断

```c
#include <reg51.h>
#define uint unsigned int
void dalay(uint i)
{
    uint j = 0;
    for(;i>0;i--)
        for(;j<125;j++);
}

void main()        // 也可以用		T0计数器
{
    TMOD = 0x50;  // 设置计数器T1为模式1
    TH1 = 0xff;  // 初始化定时器初值的高字节
    TL1 = 0xfc;  // 低字节,c=12,按四次后溢出，触发中断
    EA = 1;  // 开启总中断允许位
    ET1 = 1;  // 开启定时器T0中断允许位
    TR1 = 1;  // 启动定时器T0
    while(1); 
}

void timer() interrupt 3
{
    while(1)
    {
        P1 = 0xff;
        dalay(500);
        P1 = 0x00;
        dalay(500);
	}
}
```

## 蜂鸣器的代码

```c
#include <reg51.h>
sbit sound = P1^7;
#define f1(a) (655336 - a )/256
#define f2(a) (655336 - a )%256
unsigned int i = 500;
unsigned int j = 0;

void main(){
	TMOD = 0x10;
	TH1 =f1(i);
	TL1 = f2(i);
	EA = 1;	
	ET1 = 1;
	TR1 = 1;
	while(1)
	{
		i=460;
		while(j<2000);
		j=0;
		i=360;
		while(j<2000);
		j=0;
	}
}

void Timer() interrupt 3 using 0
{
	TR1 = 0;
	sound =~sound;
	TH1 = f1(i);
	TL1 = f2(i);
	j++;
	TR1 = 1;
}

```

# 实验四

 

## 甲级代码

==TXD发送 RXD接收==

TI 发送中断的请求标志位；发送完会置1

RI接收中断的请求标志位；接收完会置1

设置波特率必须使用T1定时器的方式2，fd表示9600

==这一章需要会计算波特率==

==写会后看看扩展部分===

```c
#include <reg51.h>
#define uchar unsigned char
#define uint unsigned int

void jia() {
    uchar temp = 0;
    
    // 设置定时器1工作在方式2（8位自动重装载）模式
    TMOD = 0x20;
    
    // 设置定时器1的初始值，用于波特率的设定
    TH1 = 0xfd;
    TL1 = 0xfd;
    
    // 设置串口工作在模式1（8位数据，可变波特率）模式
    SCON = 0x40;
    
    // 关闭波特率倍增功能
    PCON = 0x00;
    
    // 启动定时器1
    TR1 = 1;
    
    // 初始化P1口的数据为全1
    P1 = 0xff;
    
    // 进入无限循环
    while(1) {
        // 读取P1口的数据到temp变量
        temp = P1;
        
        // 将temp的值发送到串口
        SBUF = temp;
        
        // 等待发送完毕
        while(TI == 0);
        
        // 清除发送中断标志
        TI = 0;
    }
}
```

## 乙机代码

```c
#include <reg51.h>
#define uchar unsigned char
#define uint unsigned int

void yi() {
    uchar temp = 0;
    
    // 设置定时器1工作在方式2（8位自动重装载）模式
    TMOD = 0x20;
    
    // 设置定时器1的初始值，用于波特率的设定
    TH1 = 0xfd;
    TL1 = 0xfd;
    
    // 设置串口工作在模式1（8位数据，可变波特率）模式，启用接收
    SCON = 0x50;
    
    // 关闭波特率倍增功能
    PCON = 0x00;
    
    // 启动定时器1
    TR1 = 1;
    
    // 进入无限循环
    while(1) {
        // 等待接收中断标志RI置位
        while(RI == 0);
        
        // 清除接收中断标志
        RI = 0;
        
        // 读取串口缓冲区的数据到temp变量
        temp = SBUF;
        
        // 将接收到的数据写入P1口
        P1 = temp;
    }
}
```

## 终端实验

 

甲机代码

```c
#include <reg51.h>
//sbit p=PSW^0;			
unsigned char Tab[8]= {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f};
void Send(unsigned char dat)		
{		
     	TB8=PSW^0;
		SBUF=dat;
		while(TI==0); 								
     	TI=0; 					
}
void Delay (void) 				
{	unsigned char m,n;
    for(m=0;m<250;m++)
     	for(n=0;n<250;n++);
}
void main(void) 				
{	unsigned char i;
     	TMOD=0x20;				
     	SCON=0xc0;				
     	PCON=0x00;  				
     	TH1=0xfd;				
     	TL1=0xfd;
     	TR1=1;					
     while(1)
     	{	for(i=0;i<8;i++)
     		{
				Send(Tab[i]);
     			Delay( );		
     		}
     	}
}  
```

乙机代码

```c
#include <reg51.h>
sbit p=0xd0;				
unsigned char Receive(void)		
{	unsigned char dat;
     	while(RI==0); 		
     	RI=0;						
     	ACC=SBUF;					
     	if(RB8==P) 				
     	{	dat=ACC;				
     		return dat;			
     	}
}
void main(void) 				
{	
    TMOD=0x20;				
    SCON=0xd0;				
    PCON=0x00;  			
    TH1=0xfd;			
    TL1=0xfd;
    TR1=1;				
    REN=1; 						
    while(1)	
        P1= Receive();	
}

```

## 波特率的计算

 

# 实验五

 

```c
#ifndef LCD_CHAR_1602_2005_4_9
#define LCD_CHAR_1602_2005_4_9
#define uchar unsigned char
#define uint unsigned int

sbit lcdrs = P2^0;   
sbit lcdrw = P2^1;
sbit lcden = P2^2;

void delay(uint z)		 
{
    uint x,y;

    for(x=z;x>0;x--)
	{
        for(y=110;y>0;y--)
		{
		  ;
		}
    }
}

void write_com(uchar com)   
{ 
    lcdrw=0;
    lcdrs=0;
    P3=com;
    delay(5);
    lcden=1;
    delay(5);
    lcden=0;
}

void write_data(uchar date) 	
{	
    lcdrw=0;
    lcdrs=1;
    P3=date;
    delay(5);
    lcden=1;
    delay(5);
    lcden=0;
}

void init1602()		
{
    lcdrw=0;
    lcden=0;
    write_com(0x3c);
    write_com(0x0c);
    write_com(0x06);
    write_com(0x01);
    write_com(0x80);
}

void write_sfm(uchar add,uchar date)
{
	uchar shi,ge;
	shi=date/10;
	ge=date%10;
	write_com(0x80+add);
	write_data(0x30+shi);
	write_data(0x30+ge);
}
#endif
```

主程序

```c
#include <reg51.h>
#include "lcd1602.h"
#define uchar unsigned char
#define uint unsigned int
uchar int_time;
uchar second = 55;
uchar minute = 59;
uchar hour = 23;
uchar code date[] = "DATE   2023/12/14";
uchar code time[] = "TIME   23:59:55 ";

void clock_init(){
	uchar i;
	for(i = 0; i < 16; i++){
		write_data(date[i]);
	}
	write_com(0x80 + 0x40);
	
	for(i = 0; i < 16; i++){
		write_data(time[i]);
	}
}

void clock_write(uint s, uint m, uint h){
	write_sfm(0x47, h);
	write_sfm(0x4a, m);
	write_sfm(0x4d, s);
}

void main(){
	init1602();
	clock_init();
	TMOD = 0x01;
	EA = 1;
	ET0 = 1;
	TH0 = (65536 - 46483) / 256;
	TL0 = (65536 - 46483) % 256;
	TR0 = 1;
	int_time = 0;
	second = 55;
	minute = 59;
	hour = 23;
	
	while(1){
		clock_write(second, minute, hour);
	}
}

void T0_interserve(void) interrupt 1 using 1{
	int_time++;
	if(int_time == 20){
		int_time = 0;
		second++;
	}
	
	if(second == 60){
		second = 0;
		minute++;
	}
	
	if(minute == 60){
		minute = 0;
		hour++;
	}
	if(hour == 24){
		hour = 0;
	}
	
	TH0 = (65536 - 46083) / 256;
	TL0 = (65536 - 46083) % 256;
}
```

# 寄存器

## 中断请求标志寄存器IE

| TCON | TF1  | TR0  | TF0  | TR0  | IE1  | IT1  | IE0  | IT0  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |



## 中断优先级寄存器IP

### 响应中断请求的条件：

> EA = 1;
>
> 该中断源的请求标志位也必须为1
>
> 该中断源的中断允许位也必须为1
>
> 没有同级、或者更高优先级的中断正在被服务
